package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

var municipi = "08001" //Definim el municipi per la consulta dels valors climatologics
var apiKey = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJvZGlnaW9jaW9AZ21haWwuY29tIiwianRpIjoiYjRlZTViMjctZDhhMS00YmIxLWFiZjgtYmFjYTViOTc5ZDhjIiwiaXNzIjoiQUVNRVQiLCJpYXQiOjE2NzU2MTY3OTIsInVzZXJJZCI6ImI0ZWU1YjI3LWQ4YTEtNGJiMS1hYmY4LWJhY2E1Yjk3OWQ4YyIsInJvbGUiOiIifQ.y-WKC8DkAJ4O__aNkvWS60AwmYl6dVHcBZKcowfmNKs"

type PreUrl struct {
	Url    string `json:"datos"` //definimos el campo que obtendremos del Json que nos trae la API
	Client *http.Client
}

type AutoGenerated []struct {
	Origen     Origen     `json:"origen"`
	Elaborado  string     `json:"elaborado"`
	Nombre     string     `json:"nombre"`
	Provincia  string     `json:"provincia"`
	Prediccion Prediccion `json:"prediccion"`
	ID         int        `json:"id"`
	Version    float64    `json:"version"`
}
type Origen struct {
	Productor string `json:"productor"`
	Web       string `json:"web"`
	Enlace    string `json:"enlace"`
	Language  string `json:"language"`
	Copyright string `json:"copyright"`
	NotaLegal string `json:"notaLegal"`
}
type ProbPrecipitacion struct {
	Value   int    `json:"value"`
	Periodo string `json:"periodo"`
}
type CotaNieveProv struct {
	Value   string `json:"value"`
	Periodo string `json:"periodo"`
}
type EstadoCielo struct {
	Value       string `json:"value"`
	Periodo     string `json:"periodo"`
	Descripcion string `json:"descripcion"`
}
type Viento struct {
	Direccion string `json:"direccion"`
	Velocidad int    `json:"velocidad"`
	Periodo   string `json:"periodo"`
}
type RachaMax struct {
	Value   string `json:"value"`
	Periodo string `json:"periodo"`
}
type Dato struct {
	Value int `json:"value"`
	Hora  int `json:"hora"`
}
type Temperatura struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}
type SensTermica struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}
type HumedadRelativa struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}
type Dia struct {
	ProbPrecipitacion []ProbPrecipitacion `json:"probPrecipitacion"`
	CotaNieveProv     []CotaNieveProv     `json:"cotaNieveProv"`
	EstadoCielo       []EstadoCielo       `json:"estadoCielo"`
	Viento            []Viento            `json:"viento"`
	RachaMax          []RachaMax          `json:"rachaMax"`
	Temperatura       Temperatura         `json:"temperatura"`
	SensTermica       SensTermica         `json:"sensTermica"`
	HumedadRelativa   HumedadRelativa     `json:"humedadRelativa"`
	UvMax             int                 `json:"uvMax,omitempty"`
	Fecha             string              `json:"fecha"`
}

type Prediccion struct {
	Dia []Dia `json:"dia"`
}

//lo que esta en catalán es nuestro, lo que está en castellano viene del json
type Diaria struct {
	ProbPrecipitacio int `json:"probPrecipitacion"`
	TemperaturaMax int `json:"maxima"`
	TemperaturaMin int `json:"minima"`
	HumitatRelativa int `json:"humedadRelativa"`
	Time time.Time `json:"-"`
}

//función para gestionar la obtención de los datos climatologicos, correspondiente al municipio, aqui Abrera codigo 08001
func (g *Diaria) GetPrediccions() (*Diaria, error) {
	result, _ := GetPreUrl() //Definim una funció per obtenir la Url per la petició de dades climatologiques
	valors, err := GetPrediccio(result)
	return valors, err
}	

func GetPreUrl() (string, error) {
	//Definir la URL del primer GET a la api de aemet.es
	url := fmt.Sprintf("https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/diaria/08001/?api_key=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJtY3NlaXhhc0BnbWFpbC5jb20iLCJqdGkiOiI3NDRkNjk1ZS0xOGE2LTQzMDQtOWFkYy00ZTA1MTA3M2M3MDQiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTcwNzQxNDgzNiwidXNlcklkIjoiNzQ0ZDY5NWUtMThhNi00MzA0LTlhZGMtNGUwNTEwNzNjNzA0Iiwicm9sZSI6IiJ9.nXJ-B8bj6PnV4Z2zP5n_EweWig58VtXemFgcT3rD6TI")

	//Preparar la petició package http
	req, _ := http.NewRequest("GET", url, nil) //A on li indiquem el metode get, la url de la petició i el tercer parametyre com a nil

	//incloem capçalera per evitar cache
	req.Header.Add("cahce-control", "no-cache")

	//Realizamos la petición empleando el metode Do y transmitiendo la variable req como parametre, que contiene la petición en sí.
	res, err := http.DefaultClient.Do(req)

	//Controlem si és produeix un error i corresponentment err es diferent de nil
	//Control de l' error (con if, porque no hay control de error)
	if err != nil {
		log.Println("Error connectando a la Aemet")
		return "", err //retornamos un error controlado
	}

	defer res.Body.Close() //defer es similar al assync await en JavaScript. Se executa cuando llega al final del script, cuando el script peta,

	//hacemos ahora la lectura
	//capturar todo el trafico de entrada y salida con ioutil

	body, err := ioutil.ReadAll(res.Body)
	//Control de l' error
	if err != nil {
		log.Println("Error leyendo la respuesta del Json")
		return "", err //Preparamos los retornos
	}

	//Crear un struct pero vacio
	preUrl := PreUrl{}
	err = json.Unmarshal(body, &preUrl) //porque este & ? verificar
	//Control de l' error
	if err != nil {
		log.Println("Error decodificando unmarshall Json")
		return "", err //Preparamos los retornos
	}

	return preUrl.Url, err //retornamos los valores
}

func GetPrediccio(url string) (*Diaria, error) {
	//Rebem la variable url amb el endpoint autoritzat corresponent a la Predicció Especifica d'un Municipi. En aquest cas Abrera codi 08001
	//Preparar la petició mediante el package http
	req, _ := http.NewRequest("GET", url, nil) //A on li indiquem el metode get, la url de la petició i el tercer parametyre com a nil

	//incloem capçalera per evitar cache
	req.Header.Add("cahce-control", "no-cache")

	//Executem petició
	res, err := http.DefaultClient.Do(req)

	//Control de l' error (con if, porque no hay control de error)
	if err != nil {
		log.Println("Error connectando a la Aemet")
		return nil, err //Preparamos los retornos
	}

	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
	//control d' error
	if err != nil {
		log.Println("Error leyendo Json", err)
		return nil, err //Preparamos los retornos
	}

	prediccio := AutoGenerated{}                    //inicalizamos el struct
	var precipitacio, tempMax, tempMin, humitat int //inicializamos las variables por los valores
	err = json.Unmarshal([]byte(body), &prediccio)
	if err != nil {
		log.Println("error unmarshalling", err)
		return nil, err
	}



	precipitacio = prediccio[0].Prediccion.Dia[0].ProbPrecipitacion[0].Value
	tempMax = prediccio[0].Prediccion.Dia[0].Temperatura.Maxima
	tempMin = prediccio[0].Prediccion.Dia[0].Temperatura.Minima
	humitat = prediccio[0].Prediccion.Dia[0].HumedadRelativa.Maxima

	var currentInfo = Diaria{
		ProbPrecipitacio: 	precipitacio,
		TemperaturaMax: 	tempMax,
		TemperaturaMin: 	tempMin,
		HumitatRelativa: 	humitat,
		Time: 				time.Now(),
	}

	return &currentInfo, nil 
}
